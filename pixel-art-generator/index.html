<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Pattern Generator</title>
    <style>
        :root {
            --primary: #6b46c1;
            --secondary: #4c1d95;
            --accent: #f472b6;
            --bg: #1f2937;
            --text: #f9fafb;
            --panel: #374151;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #1f2937, #2d3748);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            text-align: center;
            padding: 1rem;
            width: 100%;
            background-color: var(--secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-content {
            flex: 1;
            text-align: center;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
        }

        .back-button {
            padding: 0.5rem 1rem;
            background-color: var(--primary);
            color: var(--text);
            text-decoration: none;
            border-radius: 4px;
            margin-left: 1rem;
            transition: background-color 0.2s;
        }

        .back-button:hover {
            background-color: var(--accent);
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            max-width: 1200px;
            width: 100%;
        }

        .main-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
            margin-bottom: 1rem;
            flex-direction: row-reverse;
        }

        .canvas-container {
            position: relative;
            background-color: #000;
            border: 2px solid var(--accent);
            border-radius: 4px;
            overflow: hidden;
            aspect-ratio: 1 / 1;
        }

        #pixelCanvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 512px;
            height: 512px;
        }

        .controls {
            background-color: var(--panel);
            border-radius: 8px;
            padding: 1rem;
            width: 320px;
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--accent);
            padding-bottom: 0.5rem;
        }

        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .control-item {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--secondary);
        }

        .full-width {
            grid-column: span 2;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 0.3rem;
            border-radius: 4px;
            background-color: var(--bg);
            color: var(--text);
            border: 1px solid #4b5563;
        }

        .palette-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .palette-color {
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            border: 1px solid #4b5563;
        }

        .action-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <header>
        <a href="../creative.html" class="back-button">‚Üê Back</a>
        <div class="header-content">
            <h1>Pixel Art Pattern Generator</h1>
        </div>
        <div style="width: 80px;"></div> <!-- Spacer for centering -->
    </header>

    <div class="container">
        <div class="main-area">
            <div class="canvas-container">
                <canvas id="pixelCanvas" width="128" height="128"></canvas>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>Pattern</h3>
                    <div class="control-grid">
                        <div class="control-item full-width">
                            <label for="patternStyle">Style</label>
                            <select id="patternStyle">
                                <option value="circles">Circles</option>
                                <option value="squares">Squares</option>
                                <option value="stripes">Stripes</option>
                                <option value="triangles">Triangles</option>
                                <option value="hexagons">Hexagons</option>
                                <option value="grid">Grid</option>
                            </select>
                        </div>
                        <div class="control-item">
                            <label for="scale">Scale</label>
                            <input type="range" id="scale" min="0.1" max="10" value="1" step="0.1">
                        </div>
                        <div class="control-item">
                            <label for="intensity">Intensity</label>
                            <input type="range" id="intensity" min="0" max="1" value="0.5" step="0.1">
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Symmetry</h3>
                    <div class="control-grid">
                        <div class="control-item">
                            <label for="mirrorX">Mirror Horizontally</label>
                            <input type="checkbox" id="mirrorX" checked>
                        </div>
                        <div class="control-item">
                            <label for="mirrorY">Mirror Vertically</label>
                            <input type="checkbox" id="mirrorY" checked>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Style Parameters</h3>
                    <div class="control-grid" id="dynamicControls">
                        <!-- Dynamic controls will be added here -->
                    </div>
                </div>

                <div class="control-section">
                    <h3>Colors</h3>
                    <div class="control-grid">
                        <div class="control-item">
                            <label for="primaryColor">Primary</label>
                            <input type="color" id="primaryColor" value="#6b46c1">
                        </div>
                        <div class="control-item">
                            <label for="secondaryColor">Secondary</label>
                            <input type="color" id="secondaryColor" value="#f472b6">
                        </div>
                        <div class="control-item full-width">
                            <label for="colorScheme">Color Scheme</label>
                            <select id="colorScheme">
                                <option value="random">Random</option>
                                <option value="monochrome">Monochrome</option>
                                <option value="complementary">Complementary</option>
                                <option value="analogous">Analogous</option>
                                <option value="triadic">Triadic</option>
                                <option value="pastel">Pastel</option>
                                <option value="neon">Neon</option>
                                <option value="retro">Retro</option>
                            </select>
                        </div>
                        <div class="control-item full-width">
                            <label>Generated Palette</label>
                            <div class="palette-container" id="colorPalette">
                                <!-- Color palette will be generated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Post-Processing</h3>
                    <div class="control-grid">
                        <div class="control-item">
                            <label for="blur">Blur</label>
                            <input type="range" id="blur" min="0" max="5" value="0" step="0.1">
                        </div>
                        <div class="control-item">
                            <label for="pixelate">Pixelate</label>
                            <input type="range" id="pixelate" min="1" max="8" value="1">
                        </div>
                        <div class="control-item">
                            <label for="contrast">Contrast</label>
                            <input type="range" id="contrast" min="0.5" max="2" value="1" step="0.1">
                        </div>
                        <div class="control-item">
                            <label for="brightness">Brightness</label>
                            <input type="range" id="brightness" min="0.5" max="1.5" value="1" step="0.1">
                        </div>
                    </div>
                </div>

                <div class="action-buttons">
                    <button id="generateBtn">Generate</button>
                    <button id="randomizeBtn">Randomize All</button>
                    <button id="saveBtn">Save Image</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const CANVAS_SIZE = 128;
        const PREVIEW_SIZE = 512;

        // Get DOM elements
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generateBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const saveBtn = document.getElementById('saveBtn');
        const patternStyle = document.getElementById('patternStyle');
        const scale = document.getElementById('scale');
        const intensity = document.getElementById('intensity');
        const mirrorX = document.getElementById('mirrorX');
        const mirrorY = document.getElementById('mirrorY');
        const primaryColor = document.getElementById('primaryColor');
        const secondaryColor = document.getElementById('secondaryColor');
        const colorScheme = document.getElementById('colorScheme');
        const colorPalette = document.getElementById('colorPalette');
        const dynamicControls = document.getElementById('dynamicControls');
        const blur = document.getElementById('blur');
        const pixelate = document.getElementById('pixelate');
        const contrast = document.getElementById('contrast');
        const brightness = document.getElementById('brightness');

        // Global variables
        let pixels = new Uint8ClampedArray(CANVAS_SIZE * CANVAS_SIZE * 4);
        let palette = [];
        let currentGenParams = {};

        // Utility Functions
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        function setPixel(x, y, color) {
            const i = (y * CANVAS_SIZE + x) * 4;
            pixels[i] = color.r;
            pixels[i + 1] = color.g;
            pixels[i + 2] = color.b;
            pixels[i + 3] = 255;
        }

        function getPixel(x, y) {
            const i = (y * CANVAS_SIZE + x) * 4;
            return { r: pixels[i], g: pixels[i + 1], b: pixels[i + 2] };
        }

        function updateCanvas() {
            const imageData = new ImageData(pixels, CANVAS_SIZE, CANVAS_SIZE);
            ctx.putImageData(imageData, 0, 0);
        }

        // Initialize
        function init() {
            clearCanvas();
            setupEventListeners();
            updateDynamicControls();
            generatePalette();
            generateArt();
        }

        // Clear the canvas
        function clearCanvas() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            pixels = new Uint8ClampedArray(CANVAS_SIZE * CANVAS_SIZE * 4);
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 255;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            generateBtn.addEventListener('click', generateArt);
            randomizeBtn.addEventListener('click', randomizeAll);
            saveBtn.addEventListener('click', saveImage);
            patternStyle.addEventListener('change', () => {
                updateDynamicControls();
                generateArt();
            });
            [scale, intensity, mirrorX, mirrorY].forEach(control => {
                control.addEventListener('input', generateArt);
            });
            [colorScheme, primaryColor, secondaryColor].forEach(control => {
                control.addEventListener('change', generatePalette);
            });
            [blur, pixelate, contrast, brightness].forEach(control => {
                control.addEventListener('input', applyPostProcessing);
            });
        }

        // Generate dynamic controls
        function updateDynamicControls() {
            dynamicControls.innerHTML = '';
            const style = patternStyle.value;
            switch (style) {
                case 'circles':
                    addRangeControl('rings', 'Number of Rings', 1, 20, 5, 1);
                    addRangeControl('thickness', 'Ring Thickness', 0, 1, 0.5, 0.1);
                    break;
                case 'squares':
                    addRangeControl('rotation', 'Rotation', 0, 360, 0, 1);
                    addRangeControl('sizeVariation', 'Size Variation', 0, 1, 0.5, 0.1);
                    break;
                case 'stripes':
                    addSelectControl('direction', 'Direction', [
                        { value: 'horizontal', text: 'Horizontal' },
                        { value: 'vertical', text: 'Vertical' },
                        { value: 'diagonalLeft', text: 'Diagonal Left' },
                        { value: 'diagonalRight', text: 'Diagonal Right' }
                    ]);
                    addRangeControl('stripeWidth', 'Stripe Width', 1, 20, 5, 1);
                    break;
                case 'triangles':
                    addRangeControl('density', 'Density', 1, 32, 8, 1);
                    break;
                case 'hexagons':
                    addRangeControl('density', 'Density', 1, 32, 8, 1);
                    break;
                case 'grid':
                    addRangeControl('gridSize', 'Grid Size', 1, 32, 8, 1);
                    break;
            }
        }

        function addRangeControl(id, label, min, max, value, step = 1) {
            const controlItem = document.createElement('div');
            controlItem.className = 'control-item';
            const labelElement = document.createElement('label');
            labelElement.setAttribute('for', id);
            labelElement.textContent = label;
            const input = document.createElement('input');
            input.type = 'range';
            input.id = id;
            input.min = min;
            input.max = max;
            input.value = value;
            input.step = step;
            input.addEventListener('input', generateArt);
            controlItem.appendChild(labelElement);
            controlItem.appendChild(input);
            dynamicControls.appendChild(controlItem);
        }

        function addSelectControl(id, label, options) {
            const controlItem = document.createElement('div');
            controlItem.className = 'control-item';
            const labelElement = document.createElement('label');
            labelElement.setAttribute('for', id);
            labelElement.textContent = label;
            const select = document.createElement('select');
            select.id = id;
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                select.appendChild(optionElement);
            });
            select.addEventListener('change', generateArt);
            controlItem.appendChild(labelElement);
            controlItem.appendChild(select);
            dynamicControls.appendChild(controlItem);
        }

        function updateCurrentParams() {
            currentGenParams = {};
            currentGenParams.patternStyle = patternStyle.value;
            currentGenParams.scale = parseFloat(scale.value);
            currentGenParams.intensity = parseFloat(intensity.value);
            currentGenParams.mirrorX = mirrorX.checked;
            currentGenParams.mirrorY = mirrorY.checked;
            const dynamicInputs = dynamicControls.querySelectorAll('input, select');
            dynamicInputs.forEach(input => {
                if (input.type === 'range') currentGenParams[input.id] = parseFloat(input.value);
                else if (input.type === 'checkbox') currentGenParams[input.id] = input.checked;
                else currentGenParams[input.id] = input.value;
            });
            currentGenParams.colorScheme = colorScheme.value;
            currentGenParams.primaryColor = hexToRgb(primaryColor.value);
            currentGenParams.secondaryColor = hexToRgb(secondaryColor.value);
        }

        function generatePalette() {
            const scheme = colorScheme.value;
            const primary = hexToRgb(primaryColor.value);
            const secondary = hexToRgb(secondaryColor.value);
            palette = [];
            switch (scheme) {
                case 'monochrome':
                    for (let i = 0; i < 8; i++) {
                        const factor = i / 7;
                        palette.push({ r: Math.round(primary.r * factor), g: Math.round(primary.g * factor), b: Math.round(primary.b * factor) });
                    }
                    break;
                case 'complementary':
                    const complement = { r: 255 - primary.r, g: 255 - primary.g, b: 255 - primary.b };
                    for (let i = 0; i < 8; i++) {
                        const factor = i / 7;
                        palette.push({
                            r: Math.round(primary.r * (1 - factor) + complement.r * factor),
                            g: Math.round(primary.g * (1 - factor) + complement.g * factor),
                            b: Math.round(primary.b * (1 - factor) + complement.b * factor)
                        });
                    }
                    break;
                case 'analogous':
                    const hsl = rgbToHsl(primary.r, primary.g, primary.b);
                    for (let i = 0; i < 8; i++) {
                        const newHue = (hsl.h + (i - 4) * 15 / 360) % 1;
                        palette.push(hslToRgb(newHue, hsl.s, hsl.l));
                    }
                    break;
                case 'triadic':
                    const hsl1 = rgbToHsl(primary.r, primary.g, primary.b);
                    const hsl2 = { h: (hsl1.h + 1/3) % 1, s: hsl1.s, l: hsl1.l };
                    const hsl3 = { h: (hsl1.h + 2/3) % 1, s: hsl1.s, l: hsl1.l };
                    for (let i = 0; i < 8; i++) {
                        if (i < 3) palette.push(hslToRgb(hsl1.h, hsl1.s, 0.3 + i * 0.2));
                        else if (i < 6) palette.push(hslToRgb(hsl2.h, hsl2.s, 0.3 + (i - 3) * 0.2));
                        else palette.push(hslToRgb(hsl3.h, hsl3.s, 0.3 + (i - 6) * 0.2));
                    }
                    break;
                case 'pastel':
                    const hslPrimary = rgbToHsl(primary.r, primary.g, primary.b);
                    for (let i = 0; i < 8; i++) {
                        const hue = (hslPrimary.h + i * 0.1) % 1;
                        palette.push(hslToRgb(hue, 0.3, 0.8));
                    }
                    break;
                case 'neon':
                    for (let i = 0; i < 8; i++) palette.push(hslToRgb(i / 8, 1.0, 0.6));
                    break;
                case 'retro':
                    palette = [
                        { r: 239, g: 71, b: 111 }, { r: 255, g: 209, b: 102 }, { r: 6, g: 214, b: 160 },
                        { r: 17, g: 138, b: 178 }, { r: 7, g: 59, b: 76 }, { r: 255, g: 141, b: 161 },
                        { r: 255, g: 170, b: 51 }, { r: 17, g: 167, b: 157 }
                    ];
                    break;
                case 'random':
                default:
                    for (let i = 0; i < 8; i++) {
                        palette.push({ r: Math.floor(Math.random() * 256), g: Math.floor(Math.random() * 256), b: Math.floor(Math.random() * 256) });
                    }
                    break;
            }
            updatePaletteDisplay();
            generateArt();
        }

        function updatePaletteDisplay() {
            colorPalette.innerHTML = '';
            palette.forEach((color, index) => {
                const colorElement = document.createElement('div');
                colorElement.className = 'palette-color';
                colorElement.style.backgroundColor = `rgb(${color.r},${color.g},${color.b})`;
                colorElement.dataset.index = index;
                colorElement.addEventListener('click', () => {
                    primaryColor.value = `#${((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1)}`;
                    generatePalette();
                });
                colorPalette.appendChild(colorElement);
            });
        }

        function generateArt() {
            clearCanvas();
            updateCurrentParams();
            generatePattern();
            if (currentGenParams.mirrorX) {
                for (let y = 0; y < CANVAS_SIZE; y++) {
                    for (let x = 0; x < CANVAS_SIZE / 2; x++) {
                        const leftColor = getPixel(x, y);
                        setPixel(CANVAS_SIZE - 1 - x, y, leftColor);
                    }
                }
            }
            if (currentGenParams.mirrorY) {
                for (let x = 0; x < CANVAS_SIZE; x++) {
                    for (let y = 0; y < CANVAS_SIZE / 2; y++) {
                        const topColor = getPixel(x, y);
                        setPixel(x, CANVAS_SIZE - 1 - y, topColor);
                    }
                }
            }
            updateCanvas();
            applyPostProcessing();
        }

        function generatePattern() {
            const style = currentGenParams.patternStyle;
            const scale = currentGenParams.scale;
            const intensity = currentGenParams.intensity;
            for (let y = 0; y < CANVAS_SIZE; y++) {
                for (let x = 0; x < CANVAS_SIZE; x++) {
                    let value;
                    switch (style) {
                        case 'circles':
                            const rings = currentGenParams.rings || 5;
                            const thickness = currentGenParams.thickness || 0.5;
                            const centerX = CANVAS_SIZE / 2;
                            const centerY = CANVAS_SIZE / 2;
                            const dx = x - centerX;
                            const dy = y - centerY;
                            const r = Math.sqrt(dx * dx + dy * dy);
                            const ringWidth = (CANVAS_SIZE / 2) / rings * scale;
                            const positionInRing = (r % ringWidth) / ringWidth;
                            value = positionInRing < thickness ? 1 : 0;
                            value *= intensity;
                            break;
                        case 'squares':
                            const rotation = (currentGenParams.rotation || 0) * Math.PI / 180;
                            const sizeVariation = currentGenParams.sizeVariation || 0.5;
                            const xRot = Math.cos(rotation) * x - Math.sin(rotation) * y;
                            const yRot = Math.sin(rotation) * x + Math.cos(rotation) * y;
                            value = Math.sin(xRot * scale) * Math.cos(yRot * scale);
                            value = (value + 1) / 2 * (1 + sizeVariation * Math.sin(xRot + yRot));
                            value *= intensity;
                            break;
                        case 'stripes':
                            const direction = currentGenParams.direction || 'horizontal';
                            const stripeWidth = (currentGenParams.stripeWidth || 5) / scale;
                            let a, b;
                            switch (direction) {
                                case 'horizontal': a = 0; b = 1; break;
                                case 'vertical': a = 1; b = 0; break;
                                case 'diagonalLeft': a = 1; b = 1; break;
                                case 'diagonalRight': a = 1; b = -1; break;
                            }
                            const pos = (a * x + b * y) / stripeWidth;
                            value = (Math.floor(pos) % 2 === 0) ? 1 : 0;
                            value *= intensity;
                            break;
                        case 'triangles':
                            const triDensity = (currentGenParams.density || 8) / scale;
                            value = Math.abs((x % triDensity) - (y % triDensity)) / triDensity;
                            value *= intensity;
                            break;
                        case 'hexagons':
                            const hexDensity = (currentGenParams.density || 8) / scale;
                            value = Math.sin(x * hexDensity) + Math.cos(y * hexDensity);
                            value = (value + 2) / 4;
                            value *= intensity;
                            break;
                        case 'grid':
                            const gridSize = (currentGenParams.gridSize || 8) / scale;
                            value = (x % gridSize < 1 || y % gridSize < 1) ? 1 : 0;
                            value *= intensity;
                            break;
                    }
                    const colorIndex = Math.floor(value * (palette.length - 1));
                    setPixel(x, y, palette[colorIndex] || palette[0]);
                }
            }
        }

        function applyPostProcessing() {
            const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            let data = imageData.data;
            const b = parseFloat(blur.value);
            const p = parseInt(pixelate.value);
            const c = parseFloat(contrast.value);
            const br = parseFloat(brightness.value);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * c + 128 * br));
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * c + 128 * br));
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * c + 128 * br));
            }
            ctx.putImageData(imageData, 0, 0);
            if (p > 1) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = CANVAS_SIZE / p;
                tempCanvas.height = CANVAS_SIZE / p;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0, CANVAS_SIZE / p, CANVAS_SIZE / p);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempCanvas, 0, 0, CANVAS_SIZE / p, CANVAS_SIZE / p, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            if (b > 0) ctx.filter = `blur(${b}px)`;
            else ctx.filter = 'none';
            ctx.drawImage(canvas, 0, 0);
        }

        function randomizeAll() {
            scale.value = (Math.random() * 9.9 + 0.1).toFixed(1);
            intensity.value = (Math.random() * 1).toFixed(1);
            primaryColor.value = `#${Math.floor(Math.random() * 16777215).toString(16)}`;
            secondaryColor.value = `#${Math.floor(Math.random() * 16777215).toString(16)}`;
            generatePalette();
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'pixel-art-pattern.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Start the application
        init();
    </script>
</body>
</html>